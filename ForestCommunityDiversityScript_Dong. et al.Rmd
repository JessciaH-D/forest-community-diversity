---
title: "Community Diversity_RevisionScript"
author: "Jess Dong"
date: "2025-05-22"
output: 
  html_document:
    code_download: true
    toc: true 
    toc_float: true 
  prettydoc::html_pretty:
    theme: leonids
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(betapart)
library(sf)
library(sp)
library(spdep)
library(tmap)
library(RColorBrewer)
library(classInt)
library(adespatial)
library(adegraphics)
library(randomForest)
library(diversityForest)
library(pdp)
library(plotly)
library(forcats)
library(upstartr)
library(stringr)
library(pdp)
library(scales)
library(grid)
library(cowplot)
library(colorspace)
library(viridis)
library(GWmodel)

```

# 1. Beta Diversity Dissimilarity (Temporal Dissimilarity)


## Load files
```{r}
obba1_sub <- read.csv("./Input/subset_woodyspp/obba1_sub_forestspp.csv")
obba2_sub <- read.csv("./Input/subset_woodyspp/obba2_sub_forestspp.csv")
```


## Temporal Beta Diversity Dissimilarity (Temporal Dissimilarity)

Compute Temporal Dissimilarity

```{r}
temp_dis <- beta.temp(obba1_sub[,-1], obba2_sub[,-1], index.family = "jac")

temp_dis$beta.jac 
temp_dis$beta.jtu
temp_dis$beta.jne
```

Check the Temporal Dissimilarity (beta.jac)

```{r}
range(temp_dis$beta.jac) 

hist(temp_dis$beta.jac)

# plot with ggplot - this goes to supplement

tempdis_plot <- ggplot(data=temp_dis, aes(x=beta.jac)) +
  geom_histogram(binwidth = 0.05, color="white", fill="lightblue")+
  scale_x_continuous(limits = c(0, 1), # instead of xlim
                     breaks = seq(0, 1, 0.1),
                     expand = c(0,0)) + # so that labels every 0.1
  labs(x = "Dissimilarity (0-1)", y = "Frequency", title = "Histogram of Temporal Dissimilarity")+
  theme_classic()

tempdis_plot

```

Check turnover and nestedness

```{r eval=FALSE}
# turnover
range(temp_dis$beta.jtu) 

hist(temp_dis$beta.jtu)

#nestedness

range(temp_dis$beta.jne) 

hist(temp_dis$beta.jne)

# plot them against each other

with(temp_dis, plot(sqrt(beta.jtu) ~ sqrt(beta.jne), type='n',
                     ylab=expression(sqrt(beta[jtu])), xlab=expression(sqrt(beta[jne]))))

with(temp_dis, text(y=sqrt(beta.jtu), x=sqrt(beta.jne), labels=rownames(obba1_sub)))
```

Lastly, save the temporal dissimilarity (beta.jac) as a csv and add the block column back

```{r}
# add the block identifiers back
temp_dis_df <- data.frame(block = obba1_sub$block, tempdis = temp_dis$beta.jac)

str(temp_dis_df)

```

## Visulize Temporal Dissimilarity

Load the shapefile of the survey blocks in Ohio

```{r}
# load as sf object
obba_sf <- st_read("./Input/Shapefile/OBBA_pblock_beta_exl28C3SW.shp")

str(obba_sf)
```

Check to make sure the length of the df and sf match

```{r eval=FALSE}
# check the blck ID match

all(temp_dis_df$block %in% obba_sf$MAP_LABEL)  #  TRUE

# Check row counts
nrow(temp_dis_df) == nrow(obba_sf) # TRUE
```

Add the temporal dissimilarity to the sf object

```{r}
obba_sf_update <- obba_sf |> 
  left_join(temp_dis_df, by = c("MAP_LABEL" = "block")) |> 
  select(-Dissimilar)

```


Convert the shapefile (sf object) to a spatail object (sp)

```{r}
obba_sp <- as(obba_sf_update, 'Spatial')

```

Plot

```{r}

# round up the values to two decimals for plotting

obba_sp$tempdis <- round(obba_sp$tempdis, 2)

Mypal <- c("#EFF3FF", "#BDD7E7", "#6BAED6", "#3182BD", "#08519C") 

beta_plot <- tm_shape(obba_sp, palette()) +
  tm_polygons("tempdis", palette = Mypal, n=5, style="jenks", title="") +
  tm_layout(legend.title.size = 0.7, title = "Temporal Dissimilarity", legend.outside = T, outer.margins = c(0.005, 0.005, 0.005, 0.005), inner.margins = c(0.01, 0.01, 0.01, 0.01)) + 
  tm_compass(size = 3, type = "arrow", lwd = 1, position = c (0.8,0.1)) + 
  tm_scale_bar(size = 1, position = c(0.65,0),lwd = 0.2)
beta_plot

```

# 2. Global Moran and LISA

## Define neightbourhood

Use Gabriel graph to define neighbours and inverse distance to assign weight

```{r}

# Define neighbours
coord_sp <- coordinates(obba_sp)

nbgab <- graph2nb(gabrielneigh(coord_sp), sym=T)

#plot(nbgab, coords=coord_sp)


# Assign weight based on invers distance
distgab <- nbdists(nbgab, coord_sp) 

fdist <- lapply(distgab, function(x) 1 - x/max(dist(coord_sp)))  

listw_gab <- nb2listw(nbgab, glist = fdist) 

listw_gab
```

## Global Moran of the Temporal Dissimilarity

```{r}

moran.test(obba_sp$tempdis, listw=listw_gab) 


```

## Local Indicators (LISA) of the Temproal Dissimilarity

Calculate local moran (Z scores)

```{r}
# Local moran values (I values)

ohlocI <- localmoran(obba_sp$tempdis, listw_gab, alternative = "two.sided")

# look at the I values
printCoefmat(data.frame(ohlocI))

# Add local Moran I values back into the sp to plot

moran.map <- cbind(obba_sp, ohlocI)

## plot the I statisticas - these are essentially Z scores
moran.I <- tm_shape(moran.map) + 
  tm_fill("Ii", palette = "YlGnBu", style="quantile", title="Local Moran Statistic") +
  tm_borders(alpha=.4) +
  tm_layout(legend.title.size = 0.8, title = "Ohio", legend.outside = T) +
  tm_compass(position = c("RIGHT", "BOTTOM")) + 
  tm_scale_bar(position = c("RIGHT", "BOTTOM")) 
moran.I
```

Map LISA

```{r}

# set an empty quandrant

quandrant <- vector(mode="numeric", length = nrow(ohlocI))


# center the variable of interest around the mean

m.pblk <- obba_sp$tempdis - mean(obba_sp$tempdis) 

# center the Moran's I statistics around the mean

m.local <- ohlocI[, 1] - mean(ohlocI[, 1]) 

# define alpha

a <- 0.05

# build quaqndrant 


quandrant[m.pblk >0 & m.local >0] <- 4 # high/high (hotspot), clustering
quandrant[m.pblk <0 & m.local <0] <- 1 #low/low (cold spot), clustering
quandrant[m.pblk <0 & m.local >0] <- 2 #low/high, dispersion
quandrant[m.pblk >0 & m.local <0] <- 3 #high/low
quandrant[ohlocI[,5] > a] <- 0 # not significant

# define breaks/bins

brks <- c(0, 1, 2, 3, 4)

# add the quadrant into the spatial object

lisa <- cbind(obba_sp, quandrant)

names(lisa)

# give the newly added column a name
names(lisa)[19] <- "LISA" 

# map - polygon

LISA_plot <- tm_shape(lisa) + 
  tm_polygons("LISA", title = 'Local Moran I', style='cat', breaks=brks, palette = c("grey","blue","skyblue","pink","red"), labels =  c("insignificant","low-low","low-high","high-low","high-high")) +
  tm_layout(legend.title.size = 1, title = "Spatial Patterns of Temporal Dissimilairty", legend.outside = T)
  
LISA_plot

```

# 3. Random Forest


```{r}

# load the dataset 

frst_dis <- read.csv("Input/RandomForest/tempdis_RawEnvVar_all_rename_06192025.csv")[,-1] 

names(frst_dis)

str(frst_dis)
```

## Model

First, run the basic model with default settings

```{r}

# model
set.seed(123)

rf <- randomForest(Dissimilarity~., data=frst_dis,importance=T, proximity=T)

print(rf) 

# check variable importance

round(randomForest::importance(rf),2) 
```

Next, we fine-tuning the model by selecting the \# tree and mtry (\# of variables per split)

```{r}

# (1) check the # of trees to grow to ensure low error rate  

plot(rf) 

set.seed(123)
oob_errors_100 <- replicate(50, {
  rf <- randomForest(Dissimilarity ~ ., data = frst_dis, ntree = 100) #ntree=100
  tail(rf$mse, 1)  
})
sd(oob_errors_100)  

set.seed(123)
oob_errors_250 <- replicate(50, {
  rf <- randomForest(Dissimilarity ~ ., data = frst_dis, ntree = 250) #ntree=250
  tail(rf$mse, 1)  
})
sd(oob_errors_250) 

set.seed(123)
oob_errors_500 <- replicate(50, {
  rf <- randomForest(Dissimilarity ~ ., data = frst_dis, ntree = 500) #ntree=500
  tail(rf$mse, 1)  
})
sd(oob_errors_500) 


## check the absolute values of OOB 

mean(oob_errors_250)    
mean(oob_errors_500)  




# (2) find the optimal mtry

set.seed(123)

mtry <- tuneRF(frst_dis[,-1], frst_dis$Dissimilarity, ntreeTry=500, stepFactor = 1.5, improve=0.01, trace=T, plot=T)

print(mtry)


best.m <- mtry[mtry[,2]== min(mtry[,2]),1]

print(best.m) 
```

Finally, run model with the fine-tunned settings

```{r}
set.seed(123)

rf_best <- randomForest(Dissimilarity~., data=frst_dis, mtry=best.m, ntree=500, importance=T, proximity=T)

print(rf_best) 
```

## Model Evaluation/Performance

```{r}

# MSE

rf_best$mse 

# pesudo R sqaured (R^2)

rf_best$rsq 

# the out-of-bag predicted value 

frst_dis$predict <- rf_best$predicted 

str(frst_dis) 

ggplot(frst_dis, aes(x=Dissimilarity, y=predict))+
  geom_point()+
  geom_abline(slope=1, intercept=0, color='blue')+
  labs(x='Actual', y='Predicted')+
  ggtitle('RF Actual Vs. Predicted')+
  annotate('text', x=0.15, y=0.4,
           label=paste('MSE=0.0052', '\nPseudo R2=0.24'))


```

## Variable Importance


```{r}
vimp <- read.csv("./Input/RandomForest/VariableImportance/VariableImportance_06192025.csv", check.names = F) 

str(vimp)
```

Plot

```{r}

vimp <- vimp %>%
  mutate(Variable = str_trim(Variable)) 

vi_plot <- vimp %>% 
  ggplot(aes(x = `%IncMSE`, y = fct_reorder(Variable, `%IncMSE`))) +
  geom_col (fill = "skyblue", width = 0.4)+
  scale_y_reordered() +
  geom_label(aes(label = round(`%IncMSE`, 2)), hjust = -0.1, fill = "white", color = "black", label.size = 1, fontface = "bold")+
  xlim(0, 30) +
  labs(x = "Percent Increase in MSE", y = "Variable") +
  theme(legend.position = "none",
        panel.background = element_rect(fill = "white"),
        panel.grid.major.x = element_line(color = "#A8BAC4", linewidth = 0.3), 
        axis.ticks.length = unit(0, "mm"), 
        axis.text.x = element_text(face="bold", color = "black", size = 14, angle=0), 
        axis.text.y = element_text(face="bold", color = "black", size = 12, hjust=1), 
        axis.title.x = element_text(size = 16, face = "bold"), 
        axis.title.y = element_text(size = 16, face = "bold"), 
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5))+
  labs(title = "Variable Importance")


vi_plot

```

## Partial Dependence


look at the top 3 importance variables and their effects

```{r}
# Define the top 3 variables
vars <- c("Elevation_Variability", "Forest_Mean_Patch", "Total_Forest_Area")



pdp_data <- lapply(vars, function(var) {
  partial(rf_best, pred.var = var, train = frst_dis[,-1], grid.resolution = 50) %>%
    rename(Value = !!sym(var)) %>%  
    dplyr::select(Value, yhat) %>%        
    mutate(Variable = var)         
}) %>%
  bind_rows()

# re-label the vairables and add tho the df

label <- c("Elevation_Variability" = "Elevation Variability",
           "Forest_Mean_Patch" = "Forest Mean Patch (ha)",
           "Total_Forest_Area" = "Total Forest Area (ha)")

pdp_data <- pdp_data %>% 
  mutate(Variable = fct_relevel(Variable, "Elevation_Variability", "Forest_Mean_Patch", "Total_Forest_Area"))%>% 
  mutate(variable_label = recode(Variable, !!!label))



# assign colours
colours <- c(
           "Elevation_Variability" = "#E5AD4FFF",
           "Forest_Mean_Patch" = "#6D8325FF",
           "Total_Forest_Area" = "#4B644BFF")


# Plot partial dependence using ggplot
pdp_plot_top3 <- pdp_data %>% 
  ggplot(aes(x = Value, y = yhat, color = Variable)) +
  geom_line(size = 1) +
  scale_color_manual(values = colours)+
  facet_wrap(vars(variable_label), scales = "free_x", ncol = 3) +
  labs(
    x = "Feature Value",
    y = "Partial Dependence"
  ) +
  theme_minimal() +
  theme(legend.position = "none",
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    strip.text = element_text(size = 12, face = "bold")
  )


pdp_plot_top3

```

## Variable Interactions

(1) First, run the model and check interactions with the default plots

```{r}
# model

set.seed(123)

inter_model <-interactionfor(dependent.variable.name = "Dissimilarity", data = frst_dis, importance = "both") 


# look at quantitative interactions - the strength of variable A depends on the values of varible B

inter_model$eim.quant.sorted

# qualitative interactions - the direction of variable A is influenced by the values of variable B

inter_model$eim.qual.sorted

#plot all three types - univariable, quantitative, qualitative

plot(inter_model)

# Let's just look at the top pairs of qualitative interaction variables

plotEffects(inter_model, type = "qual", indpairs = 1, twoplots=F) 

plotEffects(inter_model, type = "qual", indpairs = 2, twoplots=F) 

# also look at the top pair of quantitative interaction variables - elevation vs. core forest

plotEffects(inter_model, type = "quant", indpairs = 1, twoplots=F) 

```


(2) Make 3-D plots

Elevation Vs. Total Forest (p=0.0648)

```{r}

pd <- pdp::partial(rf_best, pred.data = frst_dis, pred.var = c("Total_Forest_Area", "Elevation_Variability")) 

# the partial dependence values need to be interpolated first

dens <- akima::interp(x=pd$Total_Forest_Area, y = pd$Elevation_Variability, z=pd$yhat)


# 3D plot with colouring scale


plot_partial1 <- plot_ly(x=dens$x, y=dens$y, z=dens$z, type='surface')

plot_partial_quantitative <-plot_partial1 %>% layout(scene = list(xaxis = list(title = "Total Forest Area (ha)"),
                                                                 yaxis = list(title = "Elevation Variability"),
                                                                 zaxis = list(title = "Dissimilarity")),
                                                     annotations = list(list(x = 0.05,  y = 0.95,  
                                                                             xref = "paper", yref = "paper",
                                                                             text = "p=0.06",
                                                                             showarrow = FALSE,
                                                                             font = list(size = 14))))
show(plot_partial_quantitative)



```

 

# 4. Spatial Heterogeneity Model (GWR)

## Aspatial OLS

(1) an OLS model is needed to check for signs of spatial non-stationary in the residuals.

```{r}

mod_lm <- lm(Dissimilarity ~ Maximum_Temperature + Minimum_Temperature + Breeding_Season_Precipitation + Non.Forest_Mean_Patch + Total_Forest_Area + Forest_Edge_Density + Forest_Mean_Patch + Largest_Patch_Index + Elevation_Variability, data=frst_dis) 

summary(mod_lm)

```


(2) Check for residual normality

```{r}

#check overall model performance

performance::check_model(mod_lm) 

# residual normality

residuals <- resid(mod_lm)
studentized_residuals <- rstudent(mod_lm)

dotchart(residuals, xlab = "Residuals") 

hist(studentized_residuals, prob=TRUE)
lines(density(studentized_residuals))

qqnorm(residuals)
qqline(residuals) 

# residual and plot 

me1 <- mean(residuals(mod_lm))
me1

sd1 <- sd(residuals(mod_lm))
sd

summary(residuals(mod_lm))

##plot - SLIGHT RIGHT TAIL
hist(residuals(mod_lm), breaks=seq(-0.3, 0.3, .02),
    col=8, probability=T,
    ylab='Density',
    main='Histogram of Residuals(OLS)',
    xlab='Residuals(OLS)')
box()
curve(dnorm(x, mean=me1, sd=sd1), from=-.3, to=.3, add=T,
    col='red', lwd=2)



# Quantitatively check for normality

PerformanceAnalytics::kurtosis(residuals, method="excess") 


shapiro.test(residuals) 



# QQ plot 

car::qqPlot(residuals(mod_lm), distribution="norm",
       xlab='', main='Quantile Comparison Plot OSL Residuals',
       envelope=.95, las=0, pch=1, lwd=2, col="black",
       line="quartiles")


```

(3) Check for spatial Heterogeneity

```{r}

# heterskedaticity

lmtest::bptest(mod_lm) 

# plot residual against the y-hat 

plot(fitted(mod_lm), residuals(mod_lm), xlab="Fitted y", ylab= "Residuals",
     main="Plot of Residuals against Fitted y")
abline(h=0)

```

## Geographically Weighted Regression Model

Above tests showed that there is (1) spatial heteroskadacity in the OLS residual (p=0.02), indicating non-stationary relations. So, GWR is justified. In terms of GWR models (basic vs. robust), the consideration is based on that the OLS model residuals are not normal (shapiro p <0.01) and there are outliers (QQplot), robust GWR is preferred in this case, as it is more resistant to the influence of outliers.

### (1) kernel and bandwidth


```{r}

library(GWmodel)

set.seed(123)

bw.abi <- bw.gwr(tempdis ~ Maxmm_T + Minmm_T + Brdng_S + Nn_Frst + Ttl_F_A + Frst_Ed + Forst_M + Lrgst_P + Elevatn, data=obba_sp, approach = 'CV', kernel = 'bisquare', adaptive = T)

print(bw.abi) 
```

### (2) Robust GWR

Model

```{r}
set.seed(123)

gwr.rob <- gwr.robust(tempdis ~ Maxmm_T + Minmm_T + Brdng_S + Nn_Frst + Ttl_F_A + Frst_Ed + Forst_M + Lrgst_P + Elevatn, data=obba_sp, bw=bw.abi, kernel = 'bisquare', adaptive = T, F123.test = T) 

gwr.rob.t.adj <- gwr.t.adjust(gwr.rob)

print(gwr.rob)

```



### (3) Visulize the non-stationary relations


```{r}

# Create a copy of the parameter SDF and add p-values
gwr_combined <- gwr.rob$SDF 

# Add p-value columns 
gwr_combined$Elevation_p <- gwr.rob.t.adj$SDF$Elevation_p
gwr_combined$Forest_Mea_p <- gwr.rob.t.adj$SDF$Forest_Mea_p 
gwr_combined$Total_Forest_Area_p <- gwr.rob.t.adj$SDF$Total_Forest_Area_p
gwr_combined$Maximum_Te_p <- gwr.rob.t.adj$SDF$Maximum_Te_p

# Verify the merge
head(gwr_combined@data) 
```


#### Elevation Variability & Temporal Dissimilarity 

```{r}
#library(colorspace)
#library(viridis)

# Define colors for parameters (divergent if negative/positive)

mycol <- viridis(3, direction = -1, option = "D")  


# Create a bivariate color column 

gwr_combined$Elevation_bivar <- ifelse(
  gwr_combined$Elevation_p < 0.05 & gwr_combined$Elevation != 0, 
  gwr_combined$Elevation,  # Use parameter value if significant
  NA                      # Mask non-significant areas
)


# Plot

ele_bivar_plot <- spplot(gwr_combined, "Elevation_bivar", 
                    col.regions = mycol,
                    cuts = 2,
                    main = list(label = "Elevation Coefficients (Significant Only, p < 0.05)", 
                               cex = 1.2, fontface = "bold", line = 1.5),
                    colorkey = list(
                      space = "right",
                      height = 0.7,  # Adjust key height
                      labels = list(
                        at = seq(min(gwr_combined$Elevation, na.rm = TRUE), 
                                max(gwr_combined$Elevation, na.rm = TRUE), 
                                length.out = 4),
                        labels = round(seq(min(gwr_combined$Elevation, na.rm = TRUE), 
                                      max(gwr_combined$Elevation, na.rm = TRUE), 
                                      length.out = 4), 2)
                    )),
                    par.settings = list(
                      layout.heights = list(
                        top.padding = 3,    
                        bottom.padding = 2,
                        main.key.padding = 1
                      )))

ele_bivar_plot

```



#### Forest Mean Patch Size & Temporal Dissimilarity

```{r}

# Define colors for parameters 

mycol_2 <- viridis(3, direction = 1, option = "D")  


# Create a bivariate color column 

gwr_combined$Forest_Mea_bivar <- ifelse(
  gwr_combined$Forest_Mea_p < 0.05 & gwr_combined$Forest_Mea != 0, 
  gwr_combined$Forest_Mea,  
  NA)                     



# Plot

frstmean_bivar_plot <- spplot(gwr_combined, "Forest_Mea_bivar", 
                    col.regions = mycol_2,
                    cuts = 2,
                    main = list(label = "Forest Mean Patch Size Coefficients (Significant Only, p < 0.05)", 
                               cex = 1.2, fontface = "bold", line = 1.5),
                    colorkey = list(
                      space = "right",
                      height = 0.7,  # Adjust key height
                      labels = list(
                        at = seq(min(gwr_combined$Forest_Mea, na.rm = TRUE), 
                                max(gwr_combined$Forest_Mea, na.rm = TRUE), 
                                length.out = 4),
                        labels = round(seq(min(gwr_combined$Forest_Mea, na.rm = TRUE), 
                                      max(gwr_combined$Forest_Mea, na.rm = TRUE), 
                                      length.out = 4), 2)
                    )),
                    par.settings = list(
                      layout.heights = list(
                        top.padding = 3,    
                        bottom.padding = 2,
                        main.key.padding = 1
                      )))

frstmean_bivar_plot

```


#### Total Forest Area & Temporal Dissimilarity

```{r}
# Define colors for parameters 

mycol_3 <- viridis(2, direction = -1, option = "D")  


# Create a bivariate color column 

gwr_combined$Total_Fores_bivar <- ifelse(
  gwr_combined$Total_Forest_Area_p < 0.05 & gwr_combined$Total_Forest_Area != 0, 
  gwr_combined$Total_Forest_Area,  # Use parameter value if significant
  NA)                     # Mask non-significant areas




# Calculate breaks based on actual data range 

val_range <- range(gwr_combined$Total_Fores_bivar, na.rm = TRUE)
breaks <- seq(val_range[1], val_range[2], length.out = 3) # 3 breaks for 2 intervals

# Plot
totalfrst_bivar_plot <- spplot(gwr_combined, "Total_Fores_bivar", 
                    col.regions = mycol_3,
                    at = breaks,  # Explicitly set the breaks
                    main = list(label = "Total Forest Area Coefficients (Significant Only, p < 0.05)", 
                               cex = 1.2, fontface = "bold", line = 1.5),
                    colorkey = list(
                      space = "right",
                      height = 0.7,
                      labels = list(
                        at = breaks[-length(breaks)] + diff(breaks)/2,  # Center labels in intervals
                        labels = round(breaks[-length(breaks)] + diff(breaks)/2, 3) # manuallky sets labels
                      )
                    ),
                    par.settings = list(
                      layout.heights = list(
                        top.padding = 3,
                        bottom.padding = 2,
                        main.key.padding = 1
                      )))
totalfrst_bivar_plot

```



#### Maximum Temperature & Temporal Dissimilarity


```{r}
# Define colors for parameters 


mycol_4 <- c(
  rev(viridis(3, begin=0.1, end=0.4)),  
  viridis(1, begin=0.5, end=0.5),       
  viridis(3, begin=0.6, end=1)           
)

# Create a bivariate color column

gwr_combined$Maximum_Te_bivar <- ifelse(
  gwr_combined$Maximum_Te_p < 0.05, 
  gwr_combined$Maximum_Te,  
  NA)                     



# Plot

maxtemp_bivar_plot <- spplot(gwr_combined, "Maximum_Te_bivar", 
                    col.regions = mycol_4,
                    cuts = 5,
                    main = list(label = "Maximum Temperature Coefficients (Significant Only, p < 0.05)", 
                               cex = 1.2, fontface = "bold", line = 1.5),
                    colorkey = list(
                      space = "right",
                      height = 0.7,  # Adjust key height
                      labels = list(
                        at = seq(min(gwr_combined$Maximum_Te, na.rm = TRUE), 
                                max(gwr_combined$Maximum_Te, na.rm = TRUE), 
                                length.out = 6),
                        labels = round(seq(min(gwr_combined$Maximum_Te, na.rm = TRUE), 
                                      max(gwr_combined$Maximum_Te, na.rm = TRUE), 
                                      length.out = 6), 2)
                    )),
                    par.settings = list(
                      layout.heights = list(
                        top.padding = 3,    # Increase top margin (gives title more space)
                        bottom.padding = 2,
                        main.key.padding = 1
                      )))

maxtemp_bivar_plot

```


